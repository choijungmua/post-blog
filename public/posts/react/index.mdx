---
title: "React 시작하기"
date: "2025-05-24"
tags: ["React"]
thumbnail: "assets/main.jpg"
excerpt: "React의 기본 Hook, 사용 방법 JSX에 대해 알아봅시다."
---

# React 시작하기

---

## Intro

React는 페이스북 [ 현 Meta ]에서 개발한 사용자 인터페이스 (UI)를 만들기 위한 자바스크립트 라이브러리입니다.<br />
컴포넌트 기반 설계로 재사용성이 높고, 가상 DOM(Virtual DOM)을 통해 성능 최적화를 지원합니다.<br />
이번 글 에서는 React의 기본 개념과, 기본 Hook들, 그리고 JSX에 대해 자세히 살펴보겠습니다.<br />

장점 : 컴포넌트 기반 설계로 재사용성이 높고, 페이지의 끊김이 없어 App처럼 동작 가능하며, 현업에서 가장 많이 사용합니다. 가상 VirtualDom을 이용하여 UI를 부드럽게 렌더링합니다.

단점 : React의 장점 중 하나인 컴포넌트 기반 설계로 재사용성이 높습니다. 하지만 규모가 커질수록 상태관리가 복잡해져서 Props Drilling이 발생할 수 있습니다. 이것을 방지하기 위해 Recoil,Redux,Zustand 등을 이용하여 별도의 상태 관리 라이브러리가 필요할 경우가 많습니다.

React는 사용자 인터페이스를 구축하기 위한 선언적이고 효율적이며 유연한 JavaScript 라이브러리입니다. "컴포넌트"라고 불리는 작고 고립된 코드 조각을 사용하여 복잡한 UI를 구성할 수 있도록 해줍니다. React는 Facebook(현 Meta)에서 개발했으며, 현재는 전 세계 수많은 개발자와 기업에서 사용하고 있습니다.

**주요 특징:**

- **선언적 프로그래밍:** React는 코드를 보고 UI가 어떻게 보일지 예측하기 쉽게 만듭니다. 데이터가 변경되면 React는 UI를 효율적으로 업데이트하고 다시 렌더링합니다.
- **컴포넌트 기반 아키텍처:** UI를 독립적이고 재사용 가능한 컴포넌트로 나눕니다. 각 컴포넌트는 자체적인 로직과 상태를 가질 수 있으며, 이를 조합하여 복잡한 UI를 만들 수 있습니다.
- **Virtual DOM:** React는 실제 DOM을 직접 조작하는 대신 Virtual DOM이라는 가상 표현을 사용합니다. 변경 사항이 발생하면 React는 Virtual DOM을 업데이트하고, 이전 Virtual DOM과 비교하여 실제 DOM에 최소한의 변경만을 적용합니다. 이를 통해 성능을 최적화합니다.
- **단방향 데이터 흐름:** 데이터는 부모 컴포넌트에서 자식 컴포넌트로 단방향으로 흐릅니다. 이는 데이터 흐름을 예측 가능하게 만들고 디버깅을 용이하게 합니다.
- **JSX:** JavaScript를 확장한 문법으로, HTML과 유사한 구문을 사용하여 UI 구조를 쉽게 작성할 수 있도록 합니다.

React는 웹 애플리케이션뿐만 아니라 React Native를 통해 모바일 애플리케이션 개발에도 사용될 수 있어, 다양한 플랫폼에서 일관된 개발 경험을 제공합니다.

---

## React 환경 세팅

React 프로젝트를 시작하는 방법은 여러 가지가 있지만, 현재 가장 권장되는 방식은 Vite와 같은 최신 빌드 도구를 사용하는 것입니다. 과거에는 Create React App(CRA)이 많이 사용되었으나, 현재는 Vite가 더 빠른 개발 서버 속도와 빌드 시간을 제공하여 많은 개발자에게 선택받고 있습니다.

**필수 조건:**

React 개발을 위해서는 Node.js와 npm(Node Package Manager) 또는 yarn이 필요합니다. Node.js를 설치하면 npm은 자동으로 함께 설치됩니다.

- **Node.js 다운로드:** [https://nodejs.org/](https://nodejs.org/)
  (최신 LTS 버전을 설치하는 것을 권장합니다.)

**Vite를 사용하여 React 프로젝트 시작하기:**

터미널 또는 명령 프롬프트에서 다음 명령어를 실행하여 새로운 React 프로젝트를 생성합니다.

- **npm 사용 시:**

  ```bash
  npm create vite@latest my-react-app -- --template react
  ```

- **yarn 사용 시:**

  ```bash
  yarn create vite my-react-app --template react
  ```

위 명령어에서 `my-react-app`은 원하는 프로젝트 이름으로 변경할 수 있습니다. `--template react`는 React 프로젝트를 생성하도록 지정하는 옵션입니다. TypeScript를 사용하고 싶다면 `--template react-ts`를 사용하면 됩니다.

프로젝트 생성이 완료되면 해당 디렉토리로 이동하여 개발 서버를 시작할 수 있습니다.

```bash
cd my-react-app
npm install # 또는 yarn install
npm run dev # 또는 yarn dev
```

개발 서버가 실행되면 터미널에 표시된 로컬 주소(일반적으로 `http://localhost:5173`)로 접속하여 React 애플리케이션을 확인할 수 있습니다. Vite는 매우 빠른 Hot Module Replacement(HMR)를 지원하여 개발 생산성을 크게 향상시킵니다.

**Next.js 환경 (React 19 지원):**

Next.js는 React를 위한 강력한 프레임워크로, 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG), 파일 시스템 기반 라우팅, API 라우트, 이미지 최적화 등 다양한 고급 기능을 기본적으로 제공합니다. React 19의 최신 기능을 활용하고자 할 때도 Next.js는 좋은 선택입니다. 현재 이 블로그도 Next.js를 기반으로 구축되었습니다.

Next.js 프로젝트를 시작하려면 다음 명령어를 사용합니다.

```bash
npx create-next-app@latest my-next-app
```

Next.js는 `app` 디렉토리(App Router) 또는 `pages` 디렉토리(Pages Router) 구조를 사용하여 라우팅을 처리하며, React Server Components와 같은 React의 최신 기능을 적극적으로 지원합니다.

**Create React App (참고용 - 현재는 Vite 권장):**

과거에 많이 사용되었던 Create React App(CRA)으로 프로젝트를 생성하는 방법은 다음과 같습니다.

```bash
npx create-react-app old-my-react-app
```

하지만 앞서 언급했듯이, 새로운 프로젝트에는 Vite 사용이 일반적으로 더 권장됩니다.

---

## JSX란?

JSX(JavaScript XML)는 JavaScript를 확장한 문법으로, React에서 UI를 표현하는 데 사용됩니다. HTML과 유사한 구문을 가지고 있어 개발자가 UI 구조를 직관적으로 이해하고 작성할 수 있도록 돕습니다. JSX는 브라우저에서 직접 실행되지 않으며, Babel과 같은 트랜스파일러를 통해 일반 JavaScript 코드로 변환됩니다. React 19에서는 향후 React 컴파일러(아직 실험적이며 점진적 도입 예정)를 통해 이러한 변환 과정이 더욱 최적화될 가능성이 있습니다.

**JSX의 주요 특징 및 사용법:**

- **HTML과 유사한 문법:**

  ```jsx
  const element = <h1>Hello, world!</h1>;
  ```

  위 코드는 HTML의 `<h1>` 태그와 매우 유사하지만, 실제로는 JavaScript 객체로 변환됩니다.

- **JavaScript 표현식 포함:** JSX 내에서 중괄호 `{}`를 사용하여 JavaScript 표현식을 삽입할 수 있습니다.

  ```jsx
  const name = "React Developer";
  const element = <h1>Hello, {name}</h1>; // "Hello, React Developer"
  ```

  ```jsx
  function formatName(user) {
    return user.firstName + " " + user.lastName;
  }

  const user = {
    firstName: "Alice",
    lastName: "Wonderland",
  };

  const element = <h1>Hello, {formatName(user)}!</h1>; // "Hello, Alice Wonderland!"
  ```

- **속성(Attributes):** HTML과 마찬가지로 JSX 요소도 속성을 가질 수 있습니다. 다만, 몇 가지 주의사항이 있습니다.

  - `class` 대신 `className`을 사용합니다. (`class`는 JavaScript의 예약어이기 때문입니다.)
  - `for` 대신 `htmlFor`를 사용합니다.
  - 속성 이름은 일반적으로 camelCase를 따릅니다 (예: `tabindex` -> `tabIndex`).
  - 속성 값으로 문자열 리터럴을 사용할 때는 따옴표를, JavaScript 표현식을 사용할 때는 중괄호를 사용합니다.

  ```jsx
  const element = <div className="greeting">Hello!</div>;
  const imageUrl = "https://via.placeholder.com/150";
  const imageElement = <img src={imageUrl} alt="Placeholder" />;
  ```

- **자식 요소:** JSX 요소는 다른 JSX 요소를 자식으로 포함할 수 있습니다.

  ```jsx
  const element = (
    <div>
      <h1>안녕하세요!</h1>
      <p>JSX는 편리합니다.</p>
    </div>
  );
  ```

- **빈 태그(Fragments):** 여러 요소를 반환해야 하지만 부모 요소로 감싸고 싶지 않을 때 `React.Fragment` 또는 단축 문법 `<></>`를 사용합니다.

  ```jsx
  // React.Fragment 사용
  function MyComponent() {
    return (
      <React.Fragment>
        <td>첫 번째 열</td>
        <td>두 번째 열</td>
      </React.Fragment>
    );
  }

  // 단축 문법 사용
  function AnotherComponent() {
    return (
      <>
        <h1>제목</h1>
        <p>내용</p>
      </>
    );
  }
  ```

- **주석:** JSX 내에서의 주석은 `{/* 주석 내용 */}`과 같이 작성합니다.

  ```jsx
  const element = (
    <div>
      {/* 이것은 JSX 주석입니다. */}
      <h1>Hello</h1>
    </div>
  );
  ```

JSX는 UI를 JavaScript 코드 내에서 직접 표현할 수 있게 하여, 로직과 뷰를 더욱 긴밀하게 연결하고 개발 생산성을 향상시킵니다.

---

## React 컴포넌트 작성법

React의 핵심 아이디어는 UI를 **컴포넌트(Component)**라는 재사용 가능한 독립적인 조각으로 나누어 개발하는 것입니다. 컴포넌트는 JavaScript 함수 또는 클래스로 작성할 수 있으며, React 16.8 버전 이후로는 함수형 컴포넌트와 Hook을 사용하는 것이 권장됩니다.

**1. 함수형 컴포넌트 (Functional Components):**

가장 간단한 형태의 React 컴포넌트는 JavaScript 함수입니다. 이 함수는 `props`라는 객체를 인자로 받아 React 엘리먼트를 반환합니다.

```jsx
// props를 받는 간단한 함수형 컴포넌트
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

// 컴포넌트 사용
const element = <Welcome name="Sara" />;
```

ES6 화살표 함수를 사용하여 더 간결하게 작성할 수도 있습니다.

```jsx
const Greeting = (props) => {
  return <p>Welcome to {props.place}!</p>;
};

// 컴포넌트 사용
const app = <Greeting place="React World" />;
```

**컴포넌트 이름 규칙:**

- 컴포넌트 이름은 항상 **대문자**로 시작해야 합니다. (예: `Welcome`, `MyButton`)
- 소문자로 시작하는 태그는 일반적인 HTML 태그로 간주됩니다. (예: `<div>`, `<button>`)

**Props (Properties):**

- `props`는 컴포넌트에 전달되는 데이터를 담고 있는 객체입니다.
- `props`는 **읽기 전용**입니다. 즉, 컴포넌트 내부에서 `props`를 직접 수정해서는 안 됩니다. 모든 React 컴포넌트는 자신의 `props`를 다룰 때 반드시 순수 함수처럼 동작해야 합니다.

**컴포넌트 합성:**

컴포넌트는 다른 컴포넌트를 자신의 출력에 포함시켜 합성할 수 있습니다. 이를 통해 복잡한 UI를 작은 컴포넌트들로 나누어 관리할 수 있습니다.

```jsx
function UserInfo(props) {
  return (
    <div className="UserInfo">
      <Avatar user={props.user} />
      <div className="UserInfo-name">{props.user.name}</div>
    </div>
  );
}

function Avatar(props) {
  return (
    <img className="Avatar" src={props.user.avatarUrl} alt={props.user.name} />
  );
}

const user = {
  name: "Jane Doe",
  avatarUrl: "https://example.com/avatar.jpg",
};

const app = <UserInfo user={user} />;
```

**2. 클래스형 컴포넌트 (Class Components):** (참고용, 함수형 컴포넌트와 Hook 사용 권장)

과거에는 `state`나 생명주기(lifecycle) 메서드를 사용하기 위해 클래스형 컴포넌트를 사용했습니다.

```jsx
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = { date: new Date() };
  }

  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date(),
    });
  }

  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

그러나 Hook의 등장으로 함수형 컴포넌트에서도 `state`와 생명주기 관련 기능을 사용할 수 있게 되어, 대부분의 경우 함수형 컴포넌트가 선호됩니다.

**컴포넌트 파일 구조 (예시):**

일반적으로 각 컴포넌트는 별도의 파일로 관리합니다. 예를 들어 `Button` 컴포넌트는 `Button.jsx` (또는 `Button.tsx` for TypeScript) 파일에 작성합니다.

`src/components/ui/button.jsx`:

```jsx
export function Button(props) {
  // props.onClick, props.children 등을 사용하여 버튼 구현
  return (
    <button onClick={props.onClick} className="my-button">
      {props.children}
    </button>
  );
}
```

다른 파일에서 사용:

```jsx
import { Button } from "./components/ui/button";

function App() {
  return (
    <div>
      <Button onClick={() => alert("Clicked!")}>Click Me</Button>
    </div>
  );
}
```

컴포넌트 기반 아키텍처는 코드의 재사용성을 높이고, 유지보수를 용이하게 하며, 테스트를 쉽게 만듭니다.

---

## State와 Effect Hook

React Hook은 함수형 컴포넌트에서 `state` 관리, 생명주기 메서드 사용 등 기존 클래스형 컴포넌트의 기능을 사용할 수 있게 해주는 함수들입니다. Hook은 React 16.8 버전에 도입되었으며, 컴포넌트 로직을 더 직관적이고 재사용 가능하게 만듭니다.

**1. `useState` (State Hook):**

`useState`는 함수형 컴포넌트 내에서 동적인 `state`(상태)를 관리할 수 있게 해주는 Hook입니다. `state`는 컴포넌트가 기억해야 하는 값으로, 이 값이 변경되면 컴포넌트는 다시 렌더링됩니다.

**사용법:**

```jsx
import React, { useState } from "react";

function Counter() {
  // useState는 [현재 state 값, state를 업데이트하는 함수] 배열을 반환합니다.
  // 0은 count state의 초기값입니다.
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
      <button onClick={() => setCount((prevCount) => prevCount - 1)}>
        Decrement
      </button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}
```

- `useState`를 호출하면 배열을 반환합니다.
  - 첫 번째 요소는 현재 `state` 값입니다. (위 예제에서는 `count`)
  - 두 번째 요소는 해당 `state`를 업데이트하는 함수입니다. (위 예제에서는 `setCount`)
- `useState`의 인자로 `state`의 초기값을 전달합니다.
- `state`를 업데이트할 때는 `setCount`와 같은 업데이트 함수를 사용해야 합니다. 직접 `state` 변수를 수정해서는 안 됩니다.
- 업데이트 함수에 새로운 값을 직접 전달하거나, 이전 `state` 값을 기반으로 새로운 값을 계산하는 함수를 전달할 수 있습니다 (`setCount(prevCount => prevCount + 1)`).

**여러 개의 State 변수:**

하나의 컴포넌트 내에서 여러 개의 `state` 변수를 가질 수 있습니다.

```jsx
function UserForm() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");

  const handleNameChange = (event) => {
    setName(event.target.value);
  };

  const handleEmailChange = (event) => {
    setEmail(event.target.value);
  };

  // ... 폼 제출 로직
  return (
    <form>
      <input
        type="text"
        value={name}
        onChange={handleNameChange}
        placeholder="Name"
      />
      <input
        type="email"
        value={email}
        onChange={handleEmailChange}
        placeholder="Email"
      />
      {/* ... */}
    </form>
  );
}
```

**2. `useEffect` (Effect Hook):**

`useEffect`는 함수형 컴포넌트에서 **사이드 이펙트(side effects)**를 수행할 수 있게 해주는 Hook입니다. 사이드 이펙트란 데이터 가져오기, 구독(subscription) 설정, DOM 직접 조작 등 컴포넌트 렌더링 외의 작업을 의미합니다. `useEffect`는 클래스형 컴포넌트의 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 생명주기 메서드들의 역할을 통합합니다.

**사용법:**

```jsx
import React, { useState, useEffect } from "react";

function Timer() {
  const [seconds, setSeconds] = useState(0);

  // useEffect의 첫 번째 인자는 실행하고자 하는 부수 효과 함수입니다.
  useEffect(() => {
    // 이 함수는 컴포넌트가 렌더링될 때마다 실행됩니다.
    document.title = `You clicked ${seconds} times`;

    const intervalId = setInterval(() => {
      setSeconds((prevSeconds) => prevSeconds + 1);
    }, 1000);

    // Clean-up 함수: 컴포넌트가 언마운트되거나, 다음 effect가 실행되기 전에 호출됩니다.
    // interval을 정리합니다.
    return () => {
      console.log("Cleaning up interval");
      clearInterval(intervalId);
      document.title = "React App"; // 언마운트 시 타이틀 초기화 (예시)
    };
  }, []); // 두 번째 인자: 의존성 배열 (dependency array)
  // 빈 배열 `[]`은 effect가 마운트 시 한 번, 언마운트 시 한 번만 실행되도록 합니다.
  // 만약 배열에 특정 state나 prop을 넣으면, 해당 값이 변경될 때만 effect가 다시 실행됩니다.

  return (
    <div>
      <p>Seconds: {seconds}</p>
    </div>
  );
}
```

- **첫 번째 인자 (Effect 함수):** 사이드 이펙트를 수행하는 함수입니다. 이 함수는 컴포넌트가 렌더링된 후에 실행됩니다.
- **두 번째 인자 (의존성 배열, Optional):**

  - **생략 시:** 컴포넌트가 렌더링될 때마다 (초기 렌더링 포함, state나 props 변경으로 인한 리렌더링 포함) effect 함수가 실행됩니다.
  - **빈 배열 `[]`:** effect 함수는 컴포넌트가 처음 마운트될 때 한 번만 실행되고, 컴포넌트가 언마운트될 때 clean-up 함수가 실행됩니다. (마치 `componentDidMount`와 `componentWillUnmount`처럼 동작)
  - **배열에 값 포함 `[value1, value2]`:** 배열 안의 값들 중 하나라도 변경될 때마다 effect 함수가 다시 실행됩니다. (마치 `componentDidUpdate`처럼 동작, 단, 초기 마운트 시에도 실행)

- **Clean-up 함수 (정리 함수, Optional):** effect 함수가 반환하는 함수입니다. 이 함수는 컴포넌트가 언마운트되기 전, 또는 다음 effect 함수가 실행되기 전에 호출되어 이전 effect에서 사용했던 리소스(구독, 타이머 등)를 정리하는 역할을 합니다.

**useEffect 사용 예시:**

- **데이터 가져오기 (Fetching Data):**

  ```jsx
  useEffect(() => {
    async function fetchData() {
      const response = await fetch("https://api.example.com/data");
      const data = await response.json();
      // setData(data);
      console.log(data);
    }
    fetchData();
  }, []); // 컴포넌트 마운트 시 한 번만 실행
  ```

- **특정 state나 prop 변경 시 작업 수행:**

  ```jsx
  const [userId, setUserId] = useState(1);
  const [userData, setUserData] = useState(null);

  useEffect(() => {
    if (!userId) return; // userId가 없으면 실행하지 않음

    async function fetchUserData() {
      const response = await fetch(`https://api.example.com/users/${userId}`);
      const data = await response.json();
      setUserData(data);
    }
    fetchUserData();
    // userId가 변경될 때마다 이 effect는 다시 실행됩니다.
    return () => {
      // 이전 userId에 대한 요청이 진행 중이었다면 취소하는 로직 (필요하다면)
      console.log(`Cleaning up effect for userId: ${userId}`);
    };
  }, [userId]);
  ```

`useState`와 `useEffect`는 함수형 컴포넌트에서 가장 기본적이고 중요한 Hook입니다. 이들을 통해 컴포넌트의 상태 관리와 사이드 이펙트 처리를 효과적으로 할 수 있습니다. React 19에서는 `use` Hook과 같이 데이터를 소비하는 새로운 방식도 도입되어, Promise나 Context 값을 더욱 선언적으로 사용할 수 있게 될 예정입니다. 예를 들어, `use(Promise)`나 `use(Context)` 형태로 비동기 작업이나 Context 값을 컴포넌트 내부에서 마치 동기적인 값처럼 다룰 수 있게 됩니다.

---

## 이벤트 처리하기

React에서 이벤트를 처리하는 방식은 DOM 요소의 이벤트를 처리하는 방식과 매우 유사하지만 몇 가지 차이점이 있습니다.

- **이벤트 이름:** React 이벤트는 camelCase를 사용합니다. 예를 들어, HTML의 `onclick`은 React에서 `onClick`이 됩니다.
- **이벤트 핸들러:** JSX에서는 문자열 대신 함수를 이벤트 핸들러로 전달합니다.

**기본적인 이벤트 처리:**

```jsx
function ActionButton() {
  function handleClick() {
    alert("Button clicked!");
  }

  return <button onClick={handleClick}>Click Me</button>;
}
```

위 예제에서 `onClick` 이벤트에 `handleClick` 함수를 전달했습니다. 사용자가 버튼을 클릭하면 `handleClick` 함수가 실행됩니다.

**이벤트 핸들러에 인자 전달하기:**

이벤트 핸들러에 추가적인 인자를 전달해야 할 경우, 화살표 함수나 `Function.prototype.bind`를 사용할 수 있습니다.

1.  **화살표 함수 사용:**

    ```jsx
    function ItemButton({ itemId, itemName }) {
      const handleItemClick = (id, name) => {
        alert(`Item ID: ${id}, Item Name: ${name}`);
      };

      // 이벤트 발생 시 handleItemClick 함수를 호출하면서 itemId와 itemName을 전달
      return (
        <button onClick={() => handleItemClick(itemId, itemName)}>
          View {itemName}
        </button>
      );
    }

    // 사용 예시
    // <ItemButton itemId={123} itemName="Awesome Gadget" />
    ```

    이 방법이 더 권장됩니다. 렌더링 시마다 새로운 함수가 생성되지만, 가독성이 좋고 `this` 컨텍스트 문제를 피할 수 있습니다.

2.  **`bind` 사용:** (클래스형 컴포넌트에서 주로 사용되던 방식)

    ```jsx
    class OldSchoolButton extends React.Component {
      constructor(props) {
        super(props);
        // this.handleClick = this.handleClick.bind(this); // 생성자에서 바인딩
      }

      handleClick(message) {
        alert(message);
      }

      render() {
        // render 메서드 내에서 bind 사용 (매 렌더링 시 새로운 함수 생성)
        return (
          <button onClick={this.handleClick.bind(this, "Hello from bind!")}>
            Click (bind)
          </button>
        );
      }
    }
    ```

**이벤트 객체 (Event Object):**

React 이벤트 핸들러는 이벤트 객체를 인자로 받습니다. 이 이벤트 객체는 브라우저의 네이티브 이벤트 객체와 유사한 인터페이스를 가지지만, 모든 브라우저에서 동일하게 동작하도록 하는 **합성 이벤트(SyntheticEvent)** 객체입니다.

```jsx
function InputLogger() {
  const handleChange = (event) => {
    // event.target은 이벤트가 발생한 DOM 요소를 가리킵니다.
    // event.target.value는 input 요소의 현재 값입니다.
    console.log("Input value:", event.target.value);
  };

  return (
    <input
      type="text"
      onChange={handleChange}
      placeholder="Type something..."
    />
  );
}
```

`event.preventDefault()`를 호출하여 기본 동작을 막을 수도 있습니다. 예를 들어, 폼 제출 시 페이지가 새로고침되는 것을 방지할 수 있습니다.

```jsx
function MyForm() {
  const handleSubmit = (event) => {
    event.preventDefault(); // 폼 제출 기본 동작 방지
    alert("Form submitted!");
    // 여기서 폼 데이터를 서버로 보내는 등의 로직을 수행할 수 있습니다.
  };

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Submit</button>
    </form>
  );
}
```

**자주 사용되는 이벤트 핸들러:**

- `onClick`
- `onChange` (주로 `<input>`, `<select>`, `<textarea>` 요소에 사용)
- `onSubmit` (주로 `<form>` 요소에 사용)
- `onMouseOver`, `onMouseOut`
- `onKeyDown`, `onKeyPress`, `onKeyUp`
- `onFocus`, `onBlur`

이벤트 처리는 사용자와 애플리케이션 간의 상호작용을 구현하는 데 필수적입니다. React는 간결하고 일관된 방식으로 이벤트를 다룰 수 있도록 지원합니다.

---

## 리스트 렌더링과 Key

React에서 데이터 배열을 기반으로 여러 개의 유사한 컴포넌트나 엘리먼트를 렌더링하는 것은 매우 일반적인 작업입니다. JavaScript의 `map()` 함수를 사용하여 배열의 각 항목을 JSX 엘리먼트로 변환하여 리스트를 렌더링할 수 있습니다.

**배열 `map()`을 이용한 리스트 렌더링:**

```jsx
function NumberList({ numbers }) {
  // numbers 배열의 각 숫자를 <li> 엘리먼트로 변환
  const listItems = numbers.map((number) => (
    <li key={number.toString()}>
      {" "}
      {/* 각 항목에 고유한 key prop을 제공해야 합니다. */}
      {number}
    </li>
  ));

  return <ul>{listItems}</ul>;
}

// 사용 예시
// const numbers = [1, 2, 3, 4, 5];
// <NumberList numbers={numbers} />
```

위 예제에서 `numbers` 배열의 각 요소를 `<li>` 엘리먼트로 매핑했습니다.

**`key` Prop의 중요성:**

리스트를 렌더링할 때 각 엘리먼트에 **`key`**라는 특별한 문자열 속성을 제공해야 합니다. `key`는 React가 어떤 항목이 변경, 추가 또는 삭제되었는지 식별하는 데 도움을 줍니다. `key`는 형제 엘리먼트 사이에서만 고유하면 됩니다 (전체적으로 고유할 필요는 없음).

**왜 `key`가 필요한가?**

React는 `key`를 사용하여 Virtual DOM을 업데이트할 때 효율성을 높입니다.

- `key`가 없으면 React는 리스트 항목의 순서가 변경되거나 항목이 추가/삭제될 때 어떤 항목이 무엇인지 정확히 알기 어렵습니다. 이로 인해 불필요한 DOM 조작이 발생하거나, 컴포넌트의 내부 `state`가 꼬일 수 있습니다.
- `key`가 있으면 React는 각 항목을 고유하게 식별하여 최소한의 변경으로 UI를 업데이트할 수 있습니다. 예를 들어, 리스트 중간에 항목이 삽입되면, `key`를 통해 기존 항목들은 그대로 두고 새 항목만 추가할 수 있습니다.

**올바른 `key` 선택:**

- **데이터의 고유 ID 사용:** 가장 좋은 방법은 데이터 자체에 있는 고유한 ID를 `key`로 사용하는 것입니다. 예를 들어, 데이터베이스에서 가져온 항목들은 보통 고유 ID를 가지고 있습니다.

  ```jsx
  const todos = [
    { id: "a", text: "Learn React" },
    { id: "b", text: "Build an app" },
    { id: "c", text: "Deploy it" },
  ];

  function TodoList({ todos }) {
    const todoItems = todos.map((todo) => <li key={todo.id}>{todo.text}</li>);
    return <ul>{todoItems}</ul>;
  }
  ```

- **배열 인덱스 사용 (주의 필요):** 데이터에 고유 ID가 없고, 리스트 항목의 순서가 절대 변경되지 않으며, 항목이 추가되거나 삭제될 때 항상 리스트의 끝에서만 발생하는 경우에 한해 배열의 인덱스를 `key`로 사용할 수 있습니다.

  ```jsx
  // 항목 순서가 바뀌거나 중간에 삽입/삭제가 일어날 가능성이 있다면 인덱스를 key로 사용하지 마세요!
  const items = ["Apple", "Banana", "Cherry"];
  const listItems = items.map(
    (item, index) => <li key={index}>{item}</li> // 최후의 수단으로, 권장되지 않음
  );
  ```

  **경고:** 항목의 순서가 변경될 수 있는 리스트에 인덱스를 `key`로 사용하면 성능 문제가 발생하거나 `state`가 잘못 관리될 수 있습니다. 예를 들어, 첫 번째 항목을 삭제하면 모든 후속 항목의 인덱스가 변경되어 React가 모든 항목을 다시 렌더링하려고 할 수 있습니다.

**`key`는 `props`로 전달되지 않습니다:**

`key`는 React가 내부적으로 사용하는 특별한 속성이며, 컴포넌트에 `props`로 전달되지 않습니다. 만약 `key`와 동일한 값을 컴포넌트 내부에서 사용하고 싶다면, 별도의 `prop` (예: `id`)으로 명시적으로 전달해야 합니다.

```jsx
function ListItem({ id, value }) {
  // 여기서 props.key는 undefined 입니다.
  // props.id를 사용해야 합니다.
  return (
    <li>
      Item ID: {id}, Value: {value}
    </li>
  );
}

function MyList({ items }) {
  const listItems = items.map((item) => (
    <ListItem key={item.id} id={item.id} value={item.text} />
  ));
  return <ul>{listItems}</ul>;
}
```

리스트와 `key`는 React에서 동적인 데이터를 효과적으로 표시하는 데 매우 중요한 개념입니다.

---

## 폼 다루기

HTML 폼(form) 엘리먼트는 사용자로부터 입력을 받는 데 사용됩니다. React에서는 폼 엘리먼트가 일반적인 DOM 엘리먼트와 다르게 동작하는데, 그 이유는 폼 엘리먼트가 자체적으로 내부 상태를 유지하기 때문입니다. React에서는 이러한 상태를 컴포넌트의 `state`로 관리하는 **제어 컴포넌트(Controlled Components)** 방식을 주로 사용합니다.

**제어 컴포넌트 (Controlled Components):**

제어 컴포넌트에서는 폼 데이터가 React 컴포넌트의 `state`에 의해 관리됩니다. 입력 필드의 값은 React `state`에 의해 결정되며, 사용자가 입력을 변경할 때마다 `state`가 업데이트되고, 이 변경된 `state`가 다시 입력 필드의 값으로 반영됩니다.

```jsx
import React, { useState } from "react";

function NameForm() {
  const [name, setName] = useState(""); // 입력 값을 위한 state

  const handleChange = (event) => {
    // 입력 값이 변경될 때마다 state 업데이트
    setName(event.target.value.toUpperCase()); // 예: 대문자로 변경
  };

  const handleSubmit = (event) => {
    alert("A name was submitted: " + name);
    event.preventDefault(); // 페이지 새로고침 방지
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input type="text" value={name} onChange={handleChange} /> {/* value prop과 onChange 핸들러 연결 */}
      </label>
      <button type="submit">Submit</button>
      <p>Current input: {name}</p>
    </form>
  );
}
```

**제어 컴포넌트의 작동 방식:**

1.  `<input type="text">` 엘리먼트에 `value` prop을 설정하여 React `state`와 연결합니다.
2.  사용자가 입력 필드에 값을 입력하면 `onChange` 이벤트가 발생합니다.
3.  `handleChange` 함수가 호출되어 `event.target.value` (새로운 입력 값)를 가져옵니다.
4.  `setName` 함수를 사용하여 React `state`를 새로운 값으로 업데이트합니다.
5.  `state`가 업데이트되면 컴포넌트가 리렌더링되고, 입력 필드의 `value`는 업데이트된 `state` 값으로 다시 설정됩니다.

**다양한 폼 엘리먼트 다루기:**

- **`<textarea>`:** `textarea`도 `input`과 유사하게 `value` prop을 사용하여 제어합니다.

  ```jsx
  const [essay, setEssay] = useState(
    "Please write an essay about your favorite DOM element."
  );

  const handleEssayChange = (event) => {
    setEssay(event.target.value);
  };

  // ...
  // <textarea value={essay} onChange={handleEssayChange} />
  ```

- **`<select>`:** `select` 태그의 `value` prop은 선택된 `<option>`의 `value`와 일치하도록 설정합니다.

  ```jsx
  const [flavor, setFlavor] = useState("coconut"); // 초기 선택 값

  const handleFlavorChange = (event) => {
    setFlavor(event.target.value);
  };

  // ...
  // <select value={flavor} onChange={handleFlavorChange}>
  //   <option value="grapefruit">Grapefruit</option>
  //   <option value="lime">Lime</option>
  //   <option value="coconut">Coconut</option>
  //   <option value="mango">Mango</option>
  // </select>
  ```

  `multiple` 옵션이 있는 `select`의 경우, `value` prop에 배열을 전달할 수 있습니다.

- **체크박스 (Checkbox) 및 라디오 버튼 (Radio Button):** `checked` prop과 `onChange` 핸들러를 사용합니다.

  ```jsx
  const [isChecked, setIsChecked] = useState(false);

  const handleCheckboxChange = (event) => {
    setIsChecked(event.target.checked);
  };

  // ...
  // <input
  //   type="checkbox"
  //   checked={isChecked}
  //   onChange={handleCheckboxChange}
  // />
  ```

**여러 입력 필드 처리:**

폼에 여러 개의 입력 필드가 있을 경우, 각 입력 필드에 `name` 속성을 부여하고 이벤트 핸들러에서 `event.target.name`을 사용하여 어떤 필드가 변경되었는지 구분할 수 있습니다.

```jsx
function Reservation() {
  const [inputs, setInputs] = useState({
    isGoing: true,
    numberOfGuests: 2,
  });

  const handleInputChange = (event) => {
    const target = event.target;
    const value = target.type === "checkbox" ? target.checked : target.value;
    const name = target.name;

    setInputs((prevInputs) => ({
      ...prevInputs, // 이전 state를 복사
      [name]: value, // 변경된 필드만 업데이트
    }));
  };

  return (
    <form>
      <label>
        Is going:
        <input
          name="isGoing"
          type="checkbox"
          checked={inputs.isGoing}
          onChange={handleInputChange}
        />
      </label>
      <br />
      <label>
        Number of guests:
        <input
          name="numberOfGuests"
          type="number"
          value={inputs.numberOfGuests}
          onChange={handleInputChange}
        />
      </label>
    </form>
  );
}
```

**비제어 컴포넌트 (Uncontrolled Components):** (참고용)

폼 데이터를 DOM 자체에서 관리하는 방식도 있습니다. 이 경우, `ref`를 사용하여 DOM 엘리먼트에 직접 접근하여 값을 가져옵니다. 상태를 React가 아닌 DOM이 직접 관리하기 때문에 "비제어"라고 불립니다. 간단한 폼이나 React 외부 라이브러리와 통합할 때 유용할 수 있지만, 대부분의 경우 제어 컴포넌트가 권장됩니다.

제어 컴포넌트는 React의 `state`를 통해 폼 데이터를 일관되게 관리할 수 있게 해주며, 입력 값에 대한 유효성 검사나 동적인 변경을 쉽게 구현할 수 있도록 합니다. React 19에서는 폼 제출과 관련된 상태(pending, data, method, action)를 쉽게 관리할 수 있는 `useFormStatus` Hook과, 서버 액션(Server Actions)을 통해 클라이언트와 서버 간의 데이터 제출 및 상태 업데이트를 더욱 원활하게 처리할 수 있는 기능이 강화되었습니다. 이러한 기능들은 점진적으로 도입되며, 복잡한 폼 처리를 더욱 간결하게 만들어 줄 것으로 기대됩니다.

---

## Context API 소개

React의 일반적인 데이터 흐름은 위에서 아래로 (부모에서 자식으로) `props`를 통해 전달됩니다. 하지만 애플리케이션의 여러 컴포넌트에서 동일한 데이터에 접근해야 하는 경우 (예: 현재 로그인한 사용자 정보, 테마, 선호 언어 등), 모든 단계마다 `props`를 전달하는 것은 번거롭고 코드를 복잡하게 만듭니다. 이를 **"Props Drilling"**이라고 합니다.

**Context API**는 이러한 `props drilling` 문제를 해결하기 위해 등장했습니다. Context는 `props`를 사용하지 않고도 컴포넌트 트리 전체에 데이터를 전달하고 공유할 수 있는 방법을 제공합니다.

**Context API의 주요 구성 요소:**

1.  **`React.createContext(defaultValue)`:**

    - Context 객체를 생성합니다.
    - 인자로 `defaultValue`를 받으며, 이 값은 Provider 아래에서 적절한 값을 찾지 못했을 때 사용됩니다.
    - 반환값은 `{ Provider, Consumer }` 객체입니다. (현재는 `useContext` Hook 사용이 더 일반적입니다.)

2.  **`Context.Provider`:**

    - Context를 구독하는 하위 컴포넌트들에게 Context의 현재 값을 전달하는 컴포넌트입니다.
    - `value` prop을 통해 전달할 값을 설정합니다.
    - `Provider` 하위의 모든 컴포넌트는 이 `value`에 접근할 수 있습니다.
    - `Provider`는 여러 개 중첩될 수 있으며, 가장 가까운 `Provider`의 `value`를 사용합니다.

3.  **`Context.Consumer` (또는 `useContext` Hook):**
    - Context의 변화를 구독하는 컴포넌트입니다.
    - `Consumer`는 함수를 자식으로 받는 패턴(render prop)을 사용하거나, 더 현대적인 방식으로는 `useContext` Hook을 사용합니다.

**`useContext` Hook 사용법:**

`useContext` Hook은 함수형 컴포넌트에서 Context 값을 쉽게 가져올 수 있게 해줍니다.

**예시: 테마 변경 기능 구현**

1.  **Context 생성 (`src/contexts/ThemeContext.js`):**

    ```javascript
    import React, { useState, createContext } from "react";

    // 1. Context 생성 (기본값 설정 가능)
    export const ThemeContext = createContext({
      theme: "light",
      toggleTheme: () => {},
    });

    // 2. Provider 컴포넌트 생성
    export function ThemeProvider({ children }) {
      const [theme, setTheme] = useState("light"); // 초기 테마는 'light'

      const toggleTheme = () => {
        setTheme((prevTheme) => (prevTheme === "light" ? "dark" : "light"));
      };

      return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
          {children}
        </ThemeContext.Provider>
      );
    }
    ```

2.  **애플리케이션 최상단에 Provider 적용 (`src/app/layout.js` 또는 특정 레이아웃):**

    ```jsx
    // layout.js 또는 App.js
    import { ThemeProvider } from "../contexts/ThemeContext"; // 경로에 맞게 수정

    export default function RootLayout({ children }) {
      return (
        <html lang="en">
          <body>
            <ThemeProvider>
              {" "}
              {/* ThemeProvider로 감싸기 */}
              {/* 다른 레이아웃 구성 요소들 */}
              {children}
            </ThemeProvider>
          </body>
        </html>
      );
    }
    ```

3.  **Context 사용 (`useContext` Hook):**

    `src/components/ui/ThemedButton.jsx`:

    ```jsx
    import React, { useContext } from "react";
    import { ThemeContext } from "../../contexts/ThemeContext"; // 경로에 맞게 수정

    export function ThemedButton() {
      // 3. useContext를 사용하여 Context 값 가져오기
      const { theme, toggleTheme } = useContext(ThemeContext);

      const buttonStyle = {
        backgroundColor: theme === "light" ? "#eee" : "#333",
        color: theme === "light" ? "#333" : "#eee",
        padding: "10px",
        border: "none",
        cursor: "pointer",
      };

      return (
        <button style={buttonStyle} onClick={toggleTheme}>
          Toggle Theme (Current: {theme})
        </button>
      );
    }
    ```

    `src/components/ui/ThemedPanel.jsx`:

    ```jsx
    import React, { useContext } from "react";
    import { ThemeContext } from "../../contexts/ThemeContext"; // 경로에 맞게 수정

    export function ThemedPanel({ children }) {
      const { theme } = useContext(ThemeContext);

      const panelStyle = {
        padding: "20px",
        margin: "20px 0",
        backgroundColor: theme === "light" ? "#fff" : "#555",
        color: theme === "light" ? "#000" : "#fff",
        border: `1px solid ${theme === "light" ? "#ccc" : "#777"}`,
      };

      return <div style={panelStyle}>{children}</div>;
    }
    ```

**Context API 사용 시 고려사항:**

- **언제 사용해야 하는가?**
  - 전역적으로 사용되는 데이터 (예: 테마, 사용자 정보, 언어 설정)
  - 많은 컴포넌트가 공유해야 하지만, `props drilling`이 심하게 발생하는 경우
- **주의점:**
  - Context는 컴포넌트 재사용성을 낮출 수 있습니다. Context에 너무 많이 의존하면 해당 Context 없이는 컴포넌트를 사용하기 어려워집니다.
  - 불필요한 리렌더링을 유발할 수 있습니다. `Provider`의 `value` prop이 변경되면 해당 `Context`를 구독하는 모든 컴포넌트가 리렌더링됩니다. 복잡한 객체를 `value`로 전달할 때는 `useMemo` 등을 사용하여 최적화하는 것을 고려해야 합니다.
  - Context는 상태 관리 라이브러리(Redux, Zustand 등)를 대체하기 위한 것이 아닙니다. 복잡한 상태 관리 로직에는 여전히 전문 상태 관리 라이브러리가 더 적합할 수 있습니다. Context는 주로 상태 전달의 편의성을 위한 도구입니다.

Context API는 React 애플리케이션에서 데이터를 효율적으로 공유하고 관리하는 강력한 방법을 제공하여, 더욱 깔끔하고 유지보수하기 쉬운 코드를 작성하는 데 도움을 줍니다.
